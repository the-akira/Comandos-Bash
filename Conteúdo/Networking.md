# Networking

## Introdução

Uma **rede de computadores** é um grupo de computadores que usa um conjunto de [protocolos de comunicação](https://en.wikipedia.org/wiki/Communication_protocol) comuns sobre interconexões [digitais](https://en.wikipedia.org/wiki/Digital_signal) com o objetivo de compartilhar recursos localizados ou fornecidos pelos *[network nodes](https://en.wikipedia.org/wiki/Node_(networking))*. As interconexões entre os *nodes* são formadas a partir de um amplo espectro de tecnologias de [rede de telecomunicações](https://en.wikipedia.org/wiki/Telecommunication_network), com base em métodos de radiofrequência e sem fio, fisicamente com fio, ópticos, que podem ser organizados em uma variedade de [topologias de rede](https://en.wikipedia.org/wiki/Network_topology).

Os *nodes* de uma rede de computadores podem ser classificados de várias maneiras como [computadores pessoais](https://en.wikipedia.org/wiki/Personal_computer), [servidores](https://en.wikipedia.org/wiki/Server_(computing)), [hardware de rede](https://en.wikipedia.org/wiki/Networking_hardware) ou [hosts](https://en.wikipedia.org/wiki/Host_(network)) de uso geral. Eles são identificados por [nomes de host](https://en.wikipedia.org/wiki/Hostname) e [endereços de rede](https://en.wikipedia.org/wiki/Network_address). Os nomes de host servem como rótulos memoráveis para os *nodes*, raramente alterados após a atribuição inicial. Os endereços de rede servem para localizar e identificar os *nodes* por protocolos de comunicação, como o [protocolo da Internet](https://en.wikipedia.org/wiki/Internet_Protocol).

As redes de computadores podem ser classificadas por muitos critérios, por exemplo, o [meio de transmissão](https://en.wikipedia.org/wiki/Transmission_medium) usado para transportar sinais, [largura de banda](https://en.wikipedia.org/wiki/Bandwidth_(computing)), [protocolos de comunicação](https://en.wikipedia.org/wiki/Communications_protocol) para organizar o tráfego da rede, o tamanho da rede, a topologia, mecanismo de controle de tráfego e intenção organizacional. A rede de computadores mais conhecida é a [Internet](https://en.wikipedia.org/wiki/Internet).

As redes de computadores suportam muitas aplicações e serviços, como acesso à [World Wide Web](https://en.wikipedia.org/wiki/World_Wide_Web), vídeo digital, áudio digital, uso compartilhado de aplicativos e servidores de armazenamento, impressoras e aparelhos de fax e uso de aplicativos de e-mail e mensagens instantâneas.

## Breve Histórico

Redes de computadores pode ser considerado um ramo da ciência da computação, engenharia da computação e telecomunicações, uma vez que depende da aplicação teórica e prática das disciplinas relacionadas. As redes de computadores foram influenciadas por uma ampla gama de desenvolvimentos tecnológicos e marcos históricos.

- No final da década de 1950, as primeiras redes de computadores incluíam o sistema de radar militar dos Estados Unidos da América: [Semi-Automatic Ground Environment](https://en.wikipedia.org/wiki/Semi-Automatic_Ground_Environment)(SAGE).
- Em 1959, Christopher Strachey entrou com um pedido de patente para *time-sharing* e John McCarthy iniciou o primeiro projeto para implementar *time-sharing* de programas de usuário no MIT. Stratchey passou o conceito para J. C. R. Licklider na Conferência de Processamento de Informação da UNESCO inaugural em Paris naquele ano. McCarthy foi fundamental na criação de três dos primeiros sistemas de *time-sharing* (Compatible Time-Sharing System em 1961, BBN Time-Sharing System em 1962 e Dartmouth Time Sharing System em 1963).
- Em 1959, Anatolii Ivanovich Kitov propôs ao Comitê Central do Partido Comunista da União Soviética um plano detalhado para a reorganização do controle das forças armadas soviéticas e da economia soviética com base em uma rede de centros de computação, o [OGAS](https://en.wikipedia.org/wiki/OGAS).
- Em 1959, o [transistor MOS](https://en.wikipedia.org/wiki/MOSFET) foi inventado por Mohamed Atalla e Dawon Kahng no Bell Labs. Mais tarde, tornou-se um dos blocos básicos de construção de virtualmente qualquer elemento da [infraestrutura de comunicações](https://en.wikipedia.org/wiki/Communications_infrastructure).
- Em 1960, o sistema de reservas de linhas aéreas comerciais conhecido como [ semi-automatic business research environment](https://en.wikipedia.org/wiki/Semi-automatic_business_research_environment)(SABRE) entrou em operação com dois [mainframes](https://en.wikipedia.org/wiki/Mainframe_computer) conectados.
- Em 1963, J. C. R. Licklider enviou um memorando para colegas de escritório discutindo o conceito de "[Rede Intergalática de Computadores](https://en.wikipedia.org/wiki/Intergalactic_Computer_Network)", uma rede de computadores destinada a permitir comunicações gerais entre usuários de computador.
- Ao longo da década de 1960, Paul Baran e Donald Davies desenvolveram independentemente o conceito de *packet switching* para transferir informações entre computadores em uma rede. Davies foi o pioneiro na implementação do conceito com a [rede NPL](https://en.wikipedia.org/wiki/NPL_network), uma rede de área local no National Physical Laboratory (Reino Unido) usando uma velocidade de linha de 768 kbit/s.
- Em 1965, a Western Electric introduziu a primeira central telefônica amplamente usada que implementou o controle de computador.
- Em 1969, os primeiros quatro *nodes* da [ARPANET](https://en.wikipedia.org/wiki/ARPANET) foram conectados usando circuitos de 50 kbit/s entre a **University of California** em Los Angeles, o **Stanford Research Institute**, a **University of California** em Santa Barbara e a **University of Utah**. Na década de 1970, Leonard Kleinrock realizou um trabalho matemático para modelar o desempenho de *packet-switched networks*, que sustentou o desenvolvimento da ARPANET. Seu trabalho teórico sobre roteamento hierárquico no final dos anos 1970 com o estudante Farouk Kamoun continua sendo crítico para a operação da Internet hoje.
- Em 1972, serviços comerciais usando X.25 foram implantados e mais tarde usados como uma infraestrutura subjacente para expandir redes [TCP/IP](https://en.wikipedia.org/wiki/TCP/IP).
- Em 1973, a rede francesa [CYCLADES](https://en.wikipedia.org/wiki/CYCLADES) foi a primeira a responsabilizar os hosts pela entrega confiável de dados, ao invés de ser um serviço centralizado da própria rede.
- Em 1973, Robert Metcalfe escreveu um memorando formal no Xerox PARC descrevendo a [Ethernet](https://en.wikipedia.org/wiki/Ethernet), um sistema de rede baseado na rede Aloha, desenvolvido na década de 1960 por Norman Abramson e colegas da Universidade do Havaí. Em julho de 1976, Robert Metcalfe e David Boggs publicaram seu artigo "Ethernet: Distributed Packet Switching for Local Computer Networks" e colaboraram em várias patentes recebidas em 1977 e 1978.
- Em 1974, Vint Cerf, Yogen Dalal e Carl Sunshine publicaram a especificação do [Protocolo de Controle de Transmissão](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)(TCP), [RFC](https://en.wikipedia.org/wiki/RFC_(identifier)) [675](https://tools.ietf.org/html/rfc675), cunhando o termo Internet como uma abreviação para internetworking.
- Em 1976, John Murphy da Datapoint Corporation criou a ARCNET, uma rede de passagem de tokens usada pela primeira vez para compartilhar dispositivos de armazenamento.
- Em 1977, a primeira rede de fibra de longa distância foi implantada pela GTE em Long Beach, Califórnia.
- Em 1977, a Xerox Network Systems (XNS) foi desenvolvida por Robert Metcalfe e Yogen Dalal na Xerox.
- Em 1979, Robert Metcalfe buscou tornar a Ethernet um padrão aberto.
- Em 1980, a Ethernet foi atualizada do protocolo original de 2,94 Mbit/s para o protocolo de 10 Mbit/s, que foi desenvolvido por Ron Crane, Bob Garner, Roy Ogus e Yogen Dalal.
- Em 1995, a capacidade de velocidade de transmissão para Ethernet aumentou de 10 Mbit/s para 100 Mbit/s. Em 1998, a Ethernet suportava velocidades de transmissão de Gigabit. Posteriormente, velocidades mais altas de até 400 Gbit/s foram adicionadas (a partir de 2018). O dimensionamento da Ethernet tem contribuído para seu uso contínuo.

Uma rede de computadores é capaz então de estender as comunicações interpessoais por meio eletrônico com várias tecnologias, como e-mail, mensagens instantâneas, chat online, chamadas de voz e vídeo e videoconferência. Uma rede permite o compartilhamento de recursos de rede e de computação. Os usuários podem acessar e usar recursos fornecidos por dispositivos na rede, como imprimir um documento em uma impressora de rede compartilhada ou usar um dispositivo de armazenamento compartilhado. Uma rede permite o compartilhamento de arquivos, dados e outros tipos de informações, dando aos usuários autorizados a capacidade de acessar informações armazenadas em outros computadores da rede. A computação distribuída usa recursos de computação em uma rede para realizar tarefas.

## O Modelo OSI

O **Open Systems Interconnection model**(modelo OSI) é um modelo conceitual que caracteriza e padroniza as funções de comunicação de um sistema de telecomunicações ou computação sem levar em conta sua estrutura interna e tecnologia subjacentes. Seu objetivo é a interoperabilidade de diversos sistemas de comunicação com protocolos de comunicação padrão. O modelo particiona um sistema de comunicação em [camadas de abstração](https://en.wikipedia.org/wiki/Abstraction_layer).

Uma camada serve à camada acima dela e é servida pela camada abaixo dela. Por exemplo, uma camada que fornece comunicações sem erros em uma rede fornece o caminho necessário para os aplicativos acima dela, enquanto ela chama a próxima camada inferior para enviar e receber pacotes que constituem o conteúdo desse caminho.

O modelo é produto do projeto Open Systems Interconnection da [International Organization for Standardization](https://en.wikipedia.org/wiki/International_Organization_for_Standardization)(ISO).

### Arquitetura de Camadas

A recomendação X.200 descreve sete camadas, rotuladas de 1 a 7. A camada 1 é a camada mais baixa neste modelo.

![img](https://raw.githubusercontent.com/the-akira/Comandos-Bash/master/Imagens/OSI.png)

#### Camada 1: Camada Física

A [camada física](https://en.wikipedia.org/wiki/Physical_layer) é responsável pela transmissão e recepção de dados brutos não estruturados entre um dispositivo e um meio de transmissão físico. Ele converte os bits digitais em sinais elétricos, de rádio ou ópticos. As especificações de camada definem características como níveis de voltagem, o tempo das mudanças de voltagem, taxas de dados físicos, distâncias máximas de transmissão, esquema de modulação, método de acesso ao canal e conectores físicos. Isso inclui o layout de pinos, tensões, impedância de linha, especificações de cabo, tempo de sinal e frequência para dispositivos sem fio. O controle da taxa de bits é feito na camada física e pode definir o modo de transmissão como [simplex](https://en.wikipedia.org/wiki/Simplex_communication), [half duplex](https://en.wikipedia.org/wiki/Duplex_(telecommunications)#Half-duplex) e [full duplex](https://en.wikipedia.org/wiki/Duplex_(telecommunications)#Full-duplex). Os componentes de uma camada física podem ser descritos em termos de uma [topologia de rede](https://en.wikipedia.org/wiki/Network_topology). As especificações da camada física estão incluídas nas especificações dos padrões onipresentes de [Bluetooth](https://en.wikipedia.org/wiki/Bluetooth), [Ethernet](https://en.wikipedia.org/wiki/Ethernet_physical_layer) e [USB](https://en.wikipedia.org/wiki/USB). Um exemplo de especificação de camada física menos conhecida seria o padrão CAN.

#### Camada 2: Camada de Link de Dados / Enlace

A [camada de enlace de dados](https://en.wikipedia.org/wiki/Data_link_layer) fornece *[node-to-node data transfer](https://en.wikipedia.org/wiki/Node-to-node_data_transfer)* - um link entre dois *nodes* conectados diretamente. Ela detecta e possivelmente corrige erros que podem ocorrer na camada física. Ela define o protocolo para estabelecer e encerrar uma conexão entre dois dispositivos fisicamente conectados e também define o protocolo para controle de fluxo entre eles.

[IEEE 802](https://en.wikipedia.org/wiki/IEEE_802) divide a camada de enlace em duas subcamadas:

- Camada [Medium access control](https://en.wikipedia.org/wiki/Medium_access_control)(MAC): Responsável por controlar como os dispositivos em uma rede obtêm acesso a um meio e permissão para transmitir dados.
- Camada [Logical link control](https://en.wikipedia.org/wiki/Logical_link_control): Responsável por identificar e encapsular os protocolos da camada de rede e controlar a verificação de erros e a sincronização de frames.

As camadas MAC e LLC de redes IEEE 802, como 802.3 Ethernet, 802.11 Wi-Fi e 802.15.4 ZigBee, operam na camada de enlace de dados.

O [Point-to-Point Protocol (PPP)](https://en.wikipedia.org/wiki/Point-to-Point_Protocol) é um protocolo da camada de enlace que pode operar em várias camadas físicas diferentes, como linhas seriais síncronas e assíncronas.

#### Camada 3: Camada de Rede

A camada de rede fornece os meios funcionais e procedimentais de transferência de sequências de dados de comprimento variável (chamados de pacotes) de um node para outro conectado em "redes diferentes". Uma rede é um meio ao qual muitos nodes podem ser conectados, em que cada node tem um endereço e que permite que os nodes conectados a ele transfiram mensagens para outros nodes conectados a ele, simplesmente fornecendo o conteúdo de uma mensagem e o endereço do node destino e deixar a rede encontrar a maneira de entregar a mensagem ao node de destino, possivelmente encaminhando-a através de nodes intermediários. Se a mensagem for muito grande para ser transmitida de um node para outro na camada de enlace de dados entre esses nodes, a rede pode implementar a entrega da mensagem dividindo a mensagem em vários fragmentos em um node, enviando os fragmentos independentemente e remontando os fragmentos em outro node. Ele pode, mas não precisa, relatar erros de entrega.

#### Camada 4: Camada de Transporte

A camada de transporte fornece os meios funcionais e procedimentais de transferência de sequências de dados de comprimento variável de uma origem para um host de destino, enquanto mantém a qualidade das funções de serviço.

A camada de transporte controla a confiabilidade de um determinado link por meio de controle de fluxo, [segmentação/dessegmentação](https://en.wikipedia.org/wiki/Packet_segmentation) e controle de erros. Alguns protocolos são orientados por estado e por conexão. Isso significa que a camada de transporte pode rastrear os segmentos e retransmitir aqueles que falham na entrega. A camada de transporte também fornece o reconhecimento da transmissão de dados bem-sucedida e envia os próximos dados se nenhum erro ocorrer. A camada de transporte cria segmentos a partir da mensagem recebida da camada de aplicação. A segmentação é o processo de dividir uma mensagem longa em mensagens menores.

Uma forma fácil de visualizar a camada de transporte é compará-la com uma agência dos correios, que trata do despacho e classificação das correspondências e encomendas enviadas. Um correio inspeciona apenas o envelope externo da correspondência para determinar sua entrega. As camadas superiores podem ter o equivalente a envelopes duplos, como serviços de apresentação criptográfica que podem ser lidos apenas pelo destinatário.

Embora não seja desenvolvido sob o Modelo de Referência OSI e não esteja estritamente em conformidade com a definição OSI da camada de transporte, o [Protocolo de Controle de Transmissão](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) (TCP) e o [Protocolo de Datagrama do Usuário](https://en.wikipedia.org/wiki/User_Datagram_Protocol) (UDP) do Conjunto de Protocolos da Internet são comumente categorizados como protocolos da camada 4 OSI.

[Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security) (TLS) fornece segurança nessa camada.

#### Camada 5: Camada de Sessão

A camada de sessão controla os diálogos (conexões) entre computadores. Ela estabelece, gerencia e termina as conexões entre o aplicativo local e remoto. Ele fornece operação full-duplex, half-duplex ou simplex e estabelece procedimentos para checkpoint, suspender, reiniciar e encerrar uma sessão. 

No modelo OSI, essa camada é responsável por fechar normalmente uma sessão, que é tratada no Transmission Control Protocol na camada de transporte do Internet Protocol Suite. Essa camada também é responsável pelo checkpoint e recuperação da sessão, o que geralmente não é usado no Internet Protocol Suite. A camada de sessão é comumente implementada explicitamente em ambientes de aplicativos que usam chamadas de procedimento remoto.

#### Camada 6: Camada de Apresentação

A camada de apresentação estabelece o contexto entre as entidades da camada de aplicativo, nas quais as entidades da camada de aplicativo podem usar sintaxe e semântica diferentes se o serviço de apresentação fornecer um mapeamento entre elas. Se um mapeamento estiver disponível, unidades de dados de protocolo de apresentação são encapsuladas em unidades de dados de protocolo de sessão e transmitidas para a [protocol stack](https://en.wikipedia.org/wiki/Protocol_stack).

Essa camada fornece independência da representação de dados, traduzindo entre os formatos de aplicativo e de rede. A camada de apresentação transforma os dados na forma que o aplicativo aceita. Essa camada formata os dados a serem enviados pela rede. Às vezes, é chamada de camada de sintaxe. A camada de apresentação pode incluir funções de compressão. A camada de apresentação negocia a sintaxe de transferência.

#### Camada 7: Camada de Aplicação

A camada de aplicação é a camada OSI mais próxima do usuário final, o que significa que tanto a camada de aplicação OSI quanto o usuário interagem diretamente com o aplicativo de software. Essa camada interage com aplicativos de software que implementam um componente de comunicação. As funções da camada de aplicação geralmente incluem a identificação de parceiros de comunicação, determinação da disponibilidade de recursos e sincronização da comunicação. Ao identificar os parceiros de comunicação, a camada de aplicação determina a identidade e a disponibilidade dos parceiros de comunicação para um aplicativo com dados a serem transmitidos. A distinção mais importante na camada de aplicação é a distinção entre a entidade do aplicativo e o aplicativo. Por exemplo, um site de reserva pode ter duas entidades de aplicativo: uma usando HTTP para se comunicar com seus usuários e outra para um protocolo de banco de dados remoto para registrar reservas. Nenhum desses protocolos tem nada a ver com reservas. Essa lógica está no próprio aplicativo. A camada de aplicação não tem meios para determinar a disponibilidade de recursos na rede.

## Endereçamento de Rede

Ao enviarmos uma carta, é necessário sabermos para quem ela está sendo enviada e de onde ela vem. Os pacotes precisam das mesmas informações, nossos hosts e outros hosts são identificados usando endereços MAC(media access control) e endereços IP. De forma a tornar mais fácil para nós, humanos, usamos nomes de host para identificar um host.

### Endereços MAC

Um endereço MAC é um identificador exclusivo usado como endereço de hardware. Este endereço nunca mudará. Quando você deseja obter acesso à Internet, sua máquina precisa ter um dispositivo chamado *network interface card*. Este adaptador de rede possui seu próprio endereço de hardware que é usado para identificar sua máquina. Um endereço MAC para um dispositivo Ethernet se parece com este `00:C4:B5:45:B2:43`. Os endereços MAC são fornecidos aos adaptadores de rede quando são fabricados. Cada fabricante possui um identificador único organizacional (OUI) para identificá-los como o fabricante. Este OUI é denotado pelos primeiros 3 bytes do endereço MAC. Por exemplo, a Dell tem `00-14-22`, portanto, um adaptador de rede da Dell pode ter um endereço MAC como: `00-14-22-34-B2-C2`.

### Endereços IP

Um endereço IP é usado para identificar um dispositivo em uma rede, eles são independentes de hardware e podem variar em sintaxe dependendo se você está usando IPv4 ou IPv6. Assumindo você está usando IPv4, um endereço IP típico seria: `10.27.13.25`. Os endereços IP são usados com o lado do software da rede. Sempre que um sistema está conectado à Internet, ele deve ter um endereço IP. Eles também podem mudar se sua rede mudar e forem exclusivos para toda a Internet (nem sempre é o caso, ler sobre [NAT](https://pt.wikipedia.org/wiki/Network_address_translation)).

É importante lembrar que é necessário software e hardware para mover pacotes pelas redes, portanto, temos identificadores para cada um, MAC(hardware) e IP(software).

### Nomes de Host

Uma última maneira de identificar nossas máquinas é por meio do nome do host. Os nomes de host pegam seu endereço IP e permitem que você vincule esse endereço a um nome legível por humanos. Em vez de se lembrar de `192.13.30.40`, você pode apenas se lembrar de `meuhost.com`.

## Gerenciamento de Redes com Linux

Existem inúmeras ferramentas e utilitários no Linux projetados para fins administrativos, que incluem as tarefas de configuração, manutenção, solução de problemas e gerenciamento de servidores e redes em data centers.

Vamos então conhecer as ferramentas de linha de comando e os utilitários mais usados para gerenciamento de redes no Linux, em diferentes categorias.

### Ferramentas de Configuração, Solução de Problemas e Debugging de Rede

**ifconfig**: É uma ferramenta de interface de linha de comando para configuração de interface de rede e também usada para inicializar interfaces no momento da inicialização do sistema. Depois que um servidor está instalado e funcionando, ela pode ser usada para atribuir um endereço IP a uma interface e ativar ou desativar a interface sob demanda.

Também é usada para visualizar o status do endereço IP, endereço de hardware(MAC), bem como tamanho da MTU(Maximum Transmission Unit) das interfaces atualmente ativas. ifconfig é, portanto, útil para *debugging* ou executar ajustes do sistema.

Vejamos um exemplo de como exibir o status de todas as interfaces de rede ativas.

```bash
ifconfig
```

Para listar todas as interfaces que estão disponíveis atualmente, sejam elas ativas ou desativadas, usamos a opção **-a**:

```bash
ifconfig -a
```

Para atribuir um endereço IP a uma interface, usamos o seguinte comando:

```bash
sudo ifconfig eth0 192.168.55.8 netmask 255.255.255.0
```

Para ativar uma interface de rede, digitamos:

```bash
sudo ifconfig up eth0
```

Para desativar ou desligar uma interface de rede:

```bash
sudo ifconfig down eth0
```

**Importante** lembrarmos que embora ifconfig seja uma ótima ferramenta, atualmente está obsoleta, sua substituição é o comando **ip**.

**ip**: O comando ip é outro utilitário de linha de comando útil para exibir e manipular roteamento, dispositivos de rede e interfaces. É um substituto para ifconfig e muitos outros comandos de rede.

O comando a seguir mostrará o endereço IP e outras informações sobre uma interface de rede.

```bash
ip addr show
```

Para atribuir temporariamente o endereço IP a uma interface de rede específica (eth0), digite.

```bash
sudo ip addr add 192.168.56.10 dev eth0
```

Para remover um endereço IP atribuído a uma interface de rede (eth0):

```bash
sudo ip addr del 192.168.56.15/24 dev eth0
```

Para mostrar a tabela de vizinhos atual no kernel, digitamos:

```bash
ip neigh
```

**ping (Packet INternet Groper)**: É um utilitário normalmente usado para testar a conectividade entre dois sistemas em uma rede (rede local (LAN) ou rede remota (WAN)). Ele usa o [ICMP](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)(Internet Control Message Protocol) para se comunicar com os *nodes* de uma rede.

Para testar a conectividade com outro *node*, basta fornecer seu IP ou nome de host:

```bash
ping google.com
```

Você também pode dizer ao ping para sair após um número especificado de pacotes **ECHO_REQUEST**, usando a opção **-c**:

```bash
ping -c 5 google.com
```

**Traceroute**: É um utilitário de linha de comando para rastrear o caminho completo de seu sistema local para outro sistema de rede. Ele imprime o número de saltos (IPs do roteador) no caminho que você percorre para chegar ao servidor final. É um utilitário de solução de problemas de rede.

Neste exemplo, estamos rastreando a rota dos pacotes do sistema local para um dos servidores do Google com endereço IP `8.8.8.8`.

```bash
traceroute 8.8.8.8
```

**MTR**: É uma ferramenta de diagnóstico de rede de linha de comando moderna que combina a funcionalidade de ping e traceroute em uma única ferramenta de diagnóstico. Seu *output*é atualizada em tempo real, por padrão, até que você saia do programa pressionando `q`.

```bash
mtr google.com
```

Você pode limitar o número de pings a um valor específico e sair do mtr após esses pings, usando a opção **-c**.

```bash
mtr -c 4 google.com
```

**route**: É um utilitário de linha de comando para exibir ou manipular a tabela de roteamento de IP de um sistema Linux. É usado principalmente para configurar rotas estáticas para hosts ou redes específicas por meio de uma interface.

Você pode visualizar a tabela de roteamento IP do Kernel com o comando:

```bash
route
```

Comandos que você pode usar para configurar o roteamento

Adicione um gateway padrão à tabela de roteamento.

```bash
sudo route add default gw <gateway-ip>
```

Adicione uma rota de rede à tabela de roteamento.

```bash
sudo route add -net <network ip/cidr> gw <gateway-ip> <interface>
```

Exclua uma entrada de rota específica da tabela de roteamento.

```bash
sudo route del -net <network ip/cidr>
```

**Nmcli**: Ferramenta de linha de comando, *scriptable*, usado para reportar o status da rede, gerenciar conexões de rede e controlar o [NetworkManager](https://en.wikipedia.org/wiki/NetworkManager).

Para ver todos os seus dispositivos de rede usamos o comando:

```bash
nmcli dev status
```

Para verificar as conexões de rede em seu sistema:

```bash
nmcli con show
```

Para ver apenas as conexões ativas, adicione a opção **-a**:

```bash
nmcli con show -a
```

### Ferramentas de Scanning e Análise de Desempenho de Rede

**netstat**: é uma ferramenta de linha de comando que exibe informações úteis, como conexões de rede, tabelas de roteamento, estatísticas de interface e muito mais sobre o subsistema de rede Linux. É útil para solução de problemas de rede e análise de desempenho.

Além disso, também é uma ferramenta de depuração de serviço de rede fundamental, usada para verificar quais programas estão escutando em quais portas. Por exemplo, o comando a seguir mostrará todas as portas TCP em modo de escuta e quais programas estão escutando nelas.

```bash
sudo netstat -tnlp
```

Para visualizar a tabela de roteamento do kernel, usamos a opção **-r** (que é equivalente à execução do comando **route**).

```bash
netstat -r
```

**ss (socket statistics)** é um utilitário de linha de comando poderoso para investigar *[sockets](https://en.wikipedia.org/wiki/Network_socket)*. Ele apresenta estatísticas de **socket** e exibe informações semelhantes ao **netstat**. Além disso, mostra mais informações TCP e de estado.

O exemplo a seguir mostra como listar todas as portas TCP (sockets) que estão abertas em um servidor.

```bash
ss -ta
```

Para exibir todas as conexões TCP ativas junto com seus temporizadores:

```bash
ss -to
```

**NC (NetCat)**: Conhecido como “Network Swiss Army knife”, é um utilitário poderoso usado para quase qualquer tarefa relacionada a sockets de domínio TCP, UDP ou UNIX. Ele é usado para conexões TCP abertas, escuta em portas TCP e UDP arbitrárias, realiza varredura de portas e muito mais.

Você também pode usá-lo como um proxy TCP simples, para *network daemon testing*, para verificar se as portas remotas estão acessíveis, etc. Além disso, você pode empregar **nc** junto com o comando **pv** para transferir arquivos entre dois computadores.

O exemplo a seguir mostra como fazer o scan de uma lista de portas:

```bash
nc -zv 192.168.0.10 20-80
```

- A opção **-z** configura o nc para simplesmente procurar daemons que estão escutando, sem enviar dados para eles. 

- A opção **-v** ativa o modo detalhado.

**nc** pode funcionar em modo de escuta e podemos escutar conexões de entrada no número da porta com a opção **-l**:

```bash
nc -l 8080
``` 

Para nos conectarmos a um sistema remoto com **nc**, podemos usar o seguinte comando:

```bash
nc google.com 80
```

Agora uma conexão ao servidor com endereço `google.com` será feita na porta 80 e agora podemos enviar instruções ao servidor. Podemos obter o conteúdo completo da página com os comandos:

```
GET / HTTP/1.1
```

ou podemos obter um banner com a informação do sistema operacional:

```
HEAD / HTTP/1.1
```

Por padrão, o utilitário **nc** faz conexões apenas com portas TCP. Mas também podemos fazer conexões com portas UDP, para isso podemos usar a opção **-u**,

```bash
nc -lu 1337
```

**nc** também pode ser usado para copiar os arquivos de um sistema para outro, embora não seja recomendado e quase todos os sistemas possuem **ssh**/**scp** instalado por padrão. Mas mesmo assim, se você se deparar com um sistema sem ssh/scp, também pode usar o nc como última opção.

Começamos com a máquina na qual os dados devem ser **recebidos** e iniciamos nc no modo de ouvinte:

```bash
nc -l -p 8080 > arquivo.txt
```

Agora, na máquina de onde os dados devem ser copiados, executamos o seguinte comando:

```bash
nc 192.168.0.10 8080 < dados.txt
```

`dados.txt` é o arquivo que deve ser enviado. A opção **–send-only** fechará a conexão assim que o arquivo for copiado. Se não estiver usando esta opção, teremos que pressionar `CTRL + C` para fechar a conexão manualmente.

Caso ocorra algum problema ou erro: Verifique se você especificou um número de porta correto no host de origem. Além disso, certifique-se de que a porta esteja acessível e não esteja bloqueada pelo firewall com a ferramenta **nmap**:

```bash
nmap -p 8080 192.168.0.10
```

**Nmap** (Network Mapper) é uma ferramenta poderosa e extremamente versátil para administradores de sistema/redes Linux. É usado para coletar informações sobre um único host ou explorar redes em uma rede inteira. O Nmap também é usado para realizar varreduras de segurança, auditoria de rede e localização de portas abertas em hosts remotos e muito mais.

Podemos fazer o scan de um host usando seu nome de host ou endereço IP, por exemplo:

```bash
nmap google.com 
```

O Nmap pode escanear vários locais de uma vez em vez de escanear um único host de cada vez. Isso é útil para infraestruturas de rede mais extensas. Existem várias maneiras de verificar vários locais ao mesmo tempo, dependendo de quantos locais você precisa examinar.

```bash
nmap google.com github.com facebook.com
```

Podemos usar o **wildcard** * para verificar uma sub-rede inteira de uma vez.

```bash
nmap 192.168.0.* 
```

Podemos usar um hífen para verificar um intervalo de endereços IP.

```bash
nmap 192.168.0.1-15
```

Além de informações gerais, o **Nmap** também pode fornecer detecção de sistema operacional, varredura de script, traceroute e detecção de versão. É importante notar que o Nmap fará o seu melhor para identificar sistemas operacionais e versões, mas nem sempre pode ser totalmente preciso.

Adicionamos a opção **-A** no comando Nmap e conseguimos descobrir as informações do sistema operacional dos hosts que são mapeados. A opção **-A** pode ser usado em combinação com outros comandos do Nmap.

```bash
nmap -A 192.168.0.10
```

A opção **-O** ativa a detecção do sistema operacional:

```bash
nmap -O 192.168.0.10
```

Às vezes, podemos precisar detectar informações de serviço e versão de portas abertas. Isso é útil para solucionar problemas, verificar vulnerabilidades ou localizar serviços que precisam ser atualizados.

```bash
nmap -sV 192.168.0.10
```

A varredura de portas(*port scanning*) é um dos utilitários básicos que o Nmap oferece e, conseqüentemente, existem algumas maneiras de personalizar esse comando.

Com a opção **-p** seguida por uma porta, podemos fazer a varredura em busca de informações sobre uma porta específica em um host.

```bash
nmap -p 80 192.168.0.10
```

Podemos fazer a varredura de várias portas com a opção **-p**, separando-as com uma vírgula:

```bash
nmap -p 22,80,443 192.168.0.10
```

Podemos também pode procurar várias portas com a opção **-p** marcando um intervalo com o hífen. Para verificar as portas em ordem, em vez de aleatoriamente, adicione a opção **-r** ao comando:

```bash
nmap -p 80-443 192.168.0.10
```

Se for necessário completar uma varredura furtiva, podemos utilizar o comando:

```bash
nmap -sS 192.168.0.10
```

Ao usarmos a opção **-sS** será iniciada uma varredura furtiva com TCP SYN. A opção **-sS** pode ser utilizada em conjunto com outros tipos de comandos Nmap. No entanto, esse tipo de verificação é mais lento e pode não ser tão agressivo quanto as outras opções.

Existem algumas maneiras de implementar a descoberta de host por meio do Nmap. Uma forma muito comum é através da opção **-sL**. Por exemplo:

```bash
nmap -sL 192.168.0.10
```

A opção **-sL** encontrará os nomes de host para um determinado host, completando uma consulta DNS para cada um. Além disso, a opção **-n** pode ser usada para pular a resolução DNS, enquanto a opção **-R** pode ser usada para sempre resolver o DNS.

Se você tiver uma longa lista de endereços que precisa verificar, poderá importar um arquivo diretamente por meio da linha de comando.

```bash
nmap -iL /arquivo.txt
```

A saída detalhada geralmente fornece muito mais informações sobre um comando. Às vezes, essa saída é desnecessária. No entanto, se você estiver depurando uma situação particularmente complicada ou quiser mais informações, pode definir o comando fornecido para o modo detalhado.

A opção **-v** fornecerá informações adicionais sobre uma varredura concluída. Ele pode ser adicionado à maioria dos comandos para fornecer mais informações. Sem a opção **-v** o Nmap geralmente retornará apenas as informações críticas disponíveis.

```bash
nmap -v 192.168.0.10
```

**lsof** é um comando que significa "*list open files*", ele é usado em muitos sistemas do tipo Unix para reportar uma lista de todos os arquivos abertos e os processos que os abriram.

Para listar todos os arquivos abertos, execute o comando lsof sem nenhum argumento:

```bash
sudo lsof
```

Para determinarmos qual programa está escutando em uma porta específica podemos usar a opção **-i**, por exemplo:

```bash
sudo lsof -i :80
sudo lsof -i :3306
sudo lsof -i :80 | grep LISTEN
```

Que deve trazer um *output* similar a este:

```
apache2    1974     root    4u  IPv6  31541      0t0  TCP *:http (LISTEN)
apache2    1986 www-data    4u  IPv6  31541      0t0  TCP *:http (LISTEN)
apache2    1987 www-data    4u  IPv6  31541      0t0  TCP *:http (LISTEN)
apache2    1988 www-data    4u  IPv6  31541      0t0  TCP *:http (LISTEN)
apache2    1991 www-data    4u  IPv6  31541      0t0  TCP *:http (LISTEN)
apache2    1992 www-data    4u  IPv6  31541      0t0  TCP *:http (LISTEN)
```

Podemos ainda obter uma lista completa dos processos com o comando:

```bash
sudo lsof -i -P -n | grep LISTEN
```

Agora, podemos obter mais informações sobre PID (*process identification number*):

```bash
ps aux | grep '[1]986'
```

Podemos usar o **ls** para descobrir o nome do processo associado ao PID **1986**:

```bash
sudo ls -l /proc/1986/exe
```

Também é possível combinarmos o **lsof** com outros comandos para nos apresentar apenas os sockets que escutam na porta 80 e então matá-los (*kill*) automaticamente:

```bash
sudo lsof -t -i tcp:80 -s tcp:listen | sudo xargs kill
```

O comando Unix **[fuser](https://en.wikipedia.org/wiki/Fuser_(Unix))** é usado para mostrar quais processos estão usando um arquivo do computador, sistema de arquivos ou [Unix socket](https://en.wikipedia.org/wiki/Unix_domain_socket).

Para descobrirmos o PID dos processos que abriram a porta TCP 80, podemos contar com os seguintes comandos:

```bash
sudo fuser 80/tcp
sudo fuser -v -n tcp 80
```

Podemos usar o fuser para matar (*kill*) um processo. Para matarmos um processo associado a uma determinada porta podemos usar:

```bash
fuser -k 80/tcp
```

Outro exemplo é eliminar todos os processos que acessam o diretório `/home` de alguma forma:

```bash
sudo fuser -km /home
```

### Utilitários de Pesquisa de DNS

O comando **host** é um utilitário simples para realizar pesquisas de DNS, ele traduz nomes de host em endereços IP e vice-versa.

```bash
host google.com
```

**dig** (domain information groper) também é outro utilitário simples de pesquisa de DNS, usado para consultar informações relacionadas ao DNS, como um registro, CNAME, registro MX, etc:

```bash
dig google.com
```

**nslookup** também é um utilitário de linha de comando popular para consultar servidores DNS de forma **interativa** e **não interativa**. É usado para consultar registros de recursos DNS (RR). Você pode descobrir o registro “A” (endereço IP) de um domínio da seguinte maneira:

```bash
nslookup google.com
```

Também é possível realizarmos uma pesquisa reversa de domínio: 

```bash
nslookup 216.58.202.206
```

**whois** é um protocolo de consulta e resposta baseado em TCP comumente usado para fornecer serviços de informação aos usuários da Internet. Ele retorna informações sobre os nomes de domínio registrados, um bloco de endereço IP, servidores de nomes e uma gama muito mais ampla de serviços de informações.

Para obter as informações sobre um endereço específico podemos usar o comando:

```bash
whois tibia.com
```

### Analisadores de Pacotes de Rede Linux

**Tcpdump** é um sniffer de rede de linha de comando muito poderoso e amplamente usado. É usado para capturar e analisar pacotes TCP/IP transmitidos ou recebidos por uma rede em uma interface específica.

Para capturar pacotes de uma determinada interface, especifique-a usando a opção **-i**:

```bash
sudo tcpdump -i wlp3s0
```

Para capturar um número específico de pacotes, usamos a opção **-c** para inserir o número desejado.

```bash
tcpdump -c 5 -i wlp3s0
```

Você também pode capturar e salvar pacotes em um arquivo para análise posterior, use a opção **-w** para especificar o arquivo de *output*.

```bash
tcpdump -w pacotes.pacs -i wlp3s0
```

**Wireshark** é uma ferramenta popular, poderosa, versátil e fácil de usar para capturar e analisar pacotes em uma rede comutada por pacotes, em tempo real.

Podemos também salvar os dados capturados em um arquivo para inspeção posterior. Ele é usado por administradores de sistema e engenheiros de rede para monitorar e inspecionar os pacotes para fins de segurança e solução de problemas.

**bmon** é um poderoso utilitário de monitoramento e depuração de rede baseado em linha de comando para sistemas do tipo Unix, que captura estatísticas relacionadas à rede e as imprime visualmente em um formato amigável. É um monitor de largura de banda e estimador de taxa em tempo real confiável e eficaz.

### Ferramentas de Transferência de Dados

**curl** é um utilitário de linha de comando para transferir dados de ou para um servidor projetado para funcionar sem interação do usuário. Com o [curl](https://curl.haxx.se/), você pode baixar ou enviar dados usando um dos protocolos suportados, incluindo HTTP, HTTPS, SCP, SFTP e FTP. curl oferece uma série de opções que permitem retomar as transferências, limitar a largura de banda, suporte de proxy, autenticação de usuário e muito mais.

As opções **-V** ou **--version** não retornarão apenas a versão, mas também os protocolos e recursos suportados em sua versão atual.

```bash
curl --version
```

Em sua forma mais simples, quando chamado sem qualquer opção, curl exibe o recurso especificado no *standard output*.

Por exemplo, para recuperar a página inicial de `pythonwebscraping.netlify.app`, podemos executar o comando:

```bash
curl https://pythonwebscraping.netlify.app/
```

Se quiser baixar um arquivo, você pode usar curl com as opções **-O** ou **-o**. O primeiro salvará o arquivo no diretório de trabalho atual com o mesmo nome que no local remoto, enquanto o último permite que você especifique um nome de arquivo e/ou local diferente.

```bash
curl -O https://raw.githubusercontent.com/the-akira/Comandos-Bash/master/Scripts/hello.sh
curl -o script.sh https://raw.githubusercontent.com/the-akira/Comandos-Bash/master/Scripts/hello.sh
```

Para baixar vários arquivos de uma vez, podemos usar várias opções **-O**, seguidas pelo URL do arquivo que desejamos baixar.

No exemplo a seguir, estamos baixando os arquivos iso Arch Linux e Debian:

```bash
curl -O http://mirrors.edge.kernel.org/archlinux/iso/2018.06.01/archlinux-2018.06.01-x86_64.iso  \
     -O https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-9.4.0-amd64-netinst.iso
```

Se combinarmos **curl** com **xargs**, seremos capazes de baixar arquivos de uma lista de URLs em um arquivo.

```bash
xargs -n 1 curl -O < listaurls.txt
```

Os cabeçalhos HTTP permitem que o servidor da web remoto envie informações adicionais sobre si mesmo junto com a solicitação real. Isso fornece ao cliente detalhes sobre como a solicitação está sendo tratada.

```bash
curl -I akiradev.netlify.app
```

Às vezes, ao baixar um arquivo, o servidor remoto pode ser configurado para bloquear o *Curl User-Agent* ou pode retornar conteúdos diferentes dependendo do dispositivo do visitante e do navegador.

Em situações como essa, para emular um navegador diferente, usamos a opção **-A**. Por exemplo, para emular o Firefox 60 usamos o comando:

```bash
curl -A "Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0" https://getfedora.org/
```

Para acessarmos um servidor FTP protegido com curl, usamos a opção **-u** e devemos especificar o nome de usuário e a senha:

```bash
curl -u FTP_USUARIO:FTP_SENHA ftp://ftp.exemplo.com/
```

Podemos baixar um único arquivo do servidor FTP usando a seguinte sintaxe:

```bash
curl -u FTP_USUARIO:FTP_SENHA ftp://ftp.exemplo.com/arquivo.tar.gz
```

Para fazer upload de um arquivo para o servidor FTP, usamos a opção **-T** seguido do nome do arquivo que desejamos fazer upload:

```bash
curl -T arquivo.tar.gz -u FTP_USUARIO:FTP_SENHA ftp://ftp.exemplo.com/
```

Para fazermos uma solicitação POST com parâmetros podemos usar o comando a seguir que enviará os parâmetros **nome** e **sobrenome**, junto com seus valores correspondentes, para `https://exemplo.com/`.

```bash
curl --data "nome=Gabriel&sobrenome=Felippe" https://exemplo.com/
```

Para aprender a como usar o **curl** para interagir com REST API's, visite este [Guia](https://akiradev.netlify.app/posts/django-rest-api/).

[GNU Wget](https://www.gnu.org/software/wget/) é um utilitário de linha de comando para baixar arquivos da web. Com o Wget, você pode baixar arquivos usando os protocolos HTTP, HTTPS e FTP. Wget oferece uma série de opções que permitem que você baixe vários arquivos, retome downloads, limite a largura de banda, downloads recursivos, baixe em segundo plano, espelhe um site da Web e muito mais.

Em sua forma mais simples, quando usado sem qualquer opção, o wget fará o download do recurso especificado em uma URL para o diretório atual.

No exemplo a seguir, estamos baixando o arquivo tar do kernel do Linux:

```bash
wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.17.2.tar.xz
```

Podemos fazer o download de um site inteiro, incluindo todas as páginas e arquivos vinculados:

```bash
wget --wait=2 --recursive --convert-links --mirror --html-extension --level=2 https://akiradev.netlify.app/
```

Alguns sites verificam o *user agent*. (agente de usuário, basicamente significa navegador). então você pode adicionar esta opção **--user-agent =**.

```bash
wget http://examplo.com/ --user-agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36'
```

### Analisando o Arquivo access.log do Apache

Os logs podem ser um aspecto extremamente importante para nosso ambiente web. Eles fornecem dados adicionais que são úteis para fins de *debugging*, fins informativos, de segurança e muito mais.

Os logs de acesso do Apache armazenam informações sobre eventos que ocorreram em seu servidor da web Apache. Por exemplo, quando alguém visita seu site, um log é registrado e armazenado para fornecer ao administrador do servidor web Apache informações como o endereço IP do visitante, quais páginas ele estava visualizando, códigos de status, navegador usado, etc.

Os servidores web Apache também fornecem aos administradores outro tipo de arquivo de log denominado **logs de erro**. Este arquivo de log é usado para fornecer mais informações sobre um erro específico que ocorreu no servidor da web. No entanto, para este exemplo, vamos nos concentrar especificamente no arquivo de **log de acesso** do Apache.

#### Localização do Arquivo access.log

Para a maioria dos usuários do apache, o log de acesso estará localizado no mesmo local. 

```
/var/log/apache/access.log
/var/log/apache2/access.log
```

Se nenhum desses caminhos levar você ao arquivo de log de acesso do Apache, então você pode ter uma configuração personalizada em seu arquivo de configuração do Apache que define onde o arquivo `access.log` está localizado. Podemos executar o seguinte comando se não conseguirmos encontrar o arquivo: `sudo locate access.log`

#### Compreendendo o Arquivo access.log

O arquivo `access.log` nos traz as informações divididas em diversas seções, vejamos um exemplo do formato usado mais comum:

```
LogFormat "%h %l %u %t \"%r\" %>s %b"
```

Em que cada seção(%) significa:

- `%h` - O endereço IP do cliente.
- `%l` - A identidade do cliente determinada por `identd` na máquina do cliente. Retornará um hífen (-) se esta informação não estiver disponível.
- `%u` - O userid do cliente, se a solicitação foi autenticada.
- `%t` - A hora em que a solicitação foi recebida.
- `\"%r\"` - A linha de solicitação que inclui o método HTTP usado, o caminho do recurso solicitado e o protocolo HTTP usado pelo cliente.
- `%>s` - O código de status que o servidor envia de volta ao cliente.
- `%b` - O tamanho do objeto solicitado.

Se uma solicitação for feita a um site usando o formato de registro mencionado acima, o registro resultante seria semelhante ao seguinte.

```
127.0.0.1 - felippe [9/Feb/2020:10:34:12 -0700] "GET /image.png HTTP/2" 200 1600
```

Caso queira customizar o seu arquivo, você pode ver a lista completa de diretivas em [Apache Module mod_log_config](http://httpd.apache.org/docs/current/mod/mod_log_config.html#formats)

#### Obtendo Informações do Arquivo access.log

Podemos contar com a ajuda dos comandos Bash para analisar o arquivo [access.log](https://github.com/the-akira/Comandos-Bash/blob/master/Arquivos/access.log) e assim extrair informações úteis dele.

Podemos por exemplo iniciar obtendo conhecimento do tamanho do arquivo com o comando **du**:

```bash
du -h access.log
```

Também podemos imprimir as 3 primeiras linhas do arquivo com o comando **head**:

```bash
head -n3 access.log
```

Podemos combinar o comando **cat** com o comando **cut** para extrairmos apenas a coluna representando o IP da máquina solicitante:

```bash
cat access.log | cut -d" " -f1
```

Podemos ainda combinar o *output* do cat e cut com os comandos `uniq -c` que irá contar o número de ocorrências repetidas e finalmente o `sort -nr` que irá ordenar os números em ordem reversa, dessa forma teremos os IPs com maior número de solicitações no topo.

```bash
cat access.log | cut -d" " -f1 | uniq -c | sort -nr
```

É possível também filtrarmos por *user-agent*, por exemplo:

```bash
cat access.log | grep "Chrome"
cat access.log | grep "Firefox"
```

Até mesmo por IP:

```bash
cat access.log | grep "115.132.104.99"
``` 

### O Protocolo Secure Shell (SSH)

**[Secure Shell](https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys)** (SSH) é um protocolo criptográfico de rede para operar serviços de rede com segurança em uma rede não segura. Suas aplicações típicas incluem linha de comando remota, login e execução de comando remoto, mas qualquer serviço de rede pode ser protegido com SSH.

- SSH fornece um canal seguro em uma rede não segura usando uma arquitetura cliente-servidor, conectando um aplicativo [cliente SSH](https://en.wikipedia.org/wiki/SSH_client) a um [servidor SSH](https://en.wikipedia.org/wiki/SSH_server). 

- A especificação do protocolo distingue entre duas versões principais, conhecidas como SSH-1 e SSH-2. A porta TCP padrão para SSH é **22**. 

- SSH geralmente é usado para acessar sistemas operacionais do tipo Unix, mas também pode ser usado no Microsoft Windows. O Windows 10 usa OpenSSH como seu cliente SSH padrão e servidor SSH.

SSH foi projetado como um substituto para Telnet e para protocolos de shell remoto inseguros, como o rsh de Berkeley e os protocolos rlogin e rexec relacionados. Esses protocolos enviam informações, notadamente senhas, em texto simples, tornando-os suscetíveis à interceptação e divulgação usando *packet analysis*. A criptografia usada por SSH se destina a fornecer confidencialidade e integridade de dados em uma rede não segura, como a Internet, embora arquivos vazados por Edward Snowden indiquem que a *National Security Agency* (NSA) pode, às vezes, descriptografar o SSH, permitindo-lhes ler, modificar e suprimir seletivamente o conteúdo das sessões SSH.

SSH usa [criptografia de chave pública](https://en.wikipedia.org/wiki/Public-key_cryptography) para **autenticar** o computador remoto e permitir que ele autentique o usuário, se necessário. Existem várias maneiras de usar o SSH; uma é usar pares de chaves públicas-privadas gerados automaticamente para simplesmente criptografar uma conexão de rede e, em seguida, usar a autenticação de senha para fazer login.

Outra maneira é usar um par de chaves públicas-privadas geradas manualmente para realizar a **autenticação**, permitindo que usuários ou programas façam login sem precisar especificar uma senha. Nesse cenário, qualquer um pode produzir um par correspondente de chaves diferentes (públicas e privadas). A chave pública é colocada em todos os computadores que devem permitir acesso ao proprietário da chave privada correspondente (o proprietário mantém a chave privada em segredo). Embora a autenticação seja baseada na chave privada, a própria chave nunca é transferida pela rede durante a autenticação. O SSH verifica apenas se a mesma pessoa que oferece a chave pública também possui a chave privada correspondente. Em todas as versões do SSH, é importante verificar as chaves públicas desconhecidas, ou seja, associar as chaves públicas às identidades, antes de aceitá-las como válidas. Aceitar a chave pública de um invasor sem validação irá autorizar um invasor não autorizado como um usuário válido.

#### Usos do SSH

SSH é um protocolo que pode ser usado para muitas aplicações em muitas plataformas, incluindo a maioria das variantes do Unix (Linux, os BSDs, incluindo o macOS da Apple e Solaris), bem como o Microsoft Windows. 

- Para fazer login em um shell em um host remoto (substituindo [Telnet](https://en.wikipedia.org/wiki/Telnet) e [rlogin](https://en.wikipedia.org/wiki/Rlogin))
- Para executar um único comando em um host remoto (substituindo [rsh](https://en.wikipedia.org/wiki/Remote_shell))
- Para configurar o login automático (sem senha) para um servidor remoto (por exemplo, usando [OpenSSH](https://en.wikipedia.org/wiki/OpenSSH))
- Em combinação com o [rsync](https://en.wikipedia.org/wiki/Rsync) para fazer backup, copiar e espelhar arquivos com eficiência e segurança
- Para [encaminhar](https://en.wikipedia.org/wiki/Port_forwarding) uma porta
- Para usar como uma VPN criptografada completa. Observe que apenas o servidor e cliente OpenSSH oferecem suporte a esse recurso.
- Para navegar na web através de uma conexão proxy criptografada com clientes SSH que suportam o protocolo [SOCKS](https://en.wikipedia.org/wiki/SOCKS).
- Para montar com segurança um diretório em um servidor remoto como um sistema de arquivos em um computador local usando [SSHFS](https://en.wikipedia.org/wiki/SSHFS).
- Para monitoramento e gerenciamento remoto automatizado de servidores por meio de um ou mais dos mecanismos discutidos acima.
- Para desenvolvimento em um dispositivo móvel ou *embedded* que suporte SSH.
- Para proteger protocolos de transferência de arquivos.

##### Protocolos de Transferência de Arquivos

Os protocolos Secure Shell são usados ​​em vários mecanismos de transferência de arquivos:

- [Secure copy](https://en.wikipedia.org/wiki/Secure_copy) (SCP) que evoluiu do protocolo [RCP](https://en.wikipedia.org/wiki/Rcp_(Unix)) sob o SSH.
- [rsync](https://en.wikipedia.org/wiki/Rsync), destinado a ser mais eficiente que o SCP. Geralmente é executado em uma conexão SSH.
- [SSH File Transfer Protocol](https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol) (SFTP), uma alternativa segura ao FTP (não confundir com FTP sobre SSH ou FTPS)
- [Fast and Secure Protocol](https://en.wikipedia.org/wiki/Fast_and_Secure_Protocol) (FASP), também conhecido como Aspera, usa SSH para controle e portas UDP para transferência de dados.

#### Comunicação Client/Server

- SSH é o Cliente
- SSHD é o servidor (Open SSH Daemon)
- O servidor deve ter SSHD instalado e executando

Podemos usar o seguinte comando para instalar o SSHD:

```bash
sudo apt install openssh-server
```

Para verificarmos se o serviço está operando podemos usar um dos comandos a seguir:

```bash
systemctl status sshd
service sshd status
```

#### Métodos de Autenticação

Exemplo de como é feita uma autenticação em um serviço SSH, utilizando um **usuário** e o **hostname** (usuário@hostname) e posteriormente informando a senha, caso esteja usando o mecanismo de autenticação por password.

```
ssh akira@192.168.0.10
```

As autenticações podem então ser feitas dos modos:

- Senha (*Password*)
- Par de chaves Pública/Privada

#### Gerando Chaves

Para gerarmos as chaves pública e privada de segurança devemos executar o seguinte comando:

```bash
ssh-keygen
```

As chaves SSH têm 2048 bits por padrão. Isso geralmente é considerado bom o suficiente para segurança, mas podemos especificar um número maior de bits para uma chave mais protegida.

Para fazer isso, incluímos o argumento **-b** com o número de bits que desejamos. A maioria dos servidores oferece suporte a chaves com um comprimento de pelo menos 4096 bits. Chaves mais longas podem não ser aceitas para fins de proteção DDOS:

```bash
ssh-keygen -b 4096
```

Se uma chave diferente já foi criada, será perguntado se desejamos substituir a chave anterior: Se escolhermos “sim”, a chave anterior será substituída e não poderemos mais nos conectarmos aos servidores usando essa chave. Por isso, devemos nos certificar de substituir as chaves com cuidado.

Elas serão então geradas e irão existir nos seguintes caminhos:

- `~/.ssh/id_rsa` (Chave privada)
- `~/.ssh/id_rsa.pub` (Chave pública)

A chave pública deve estar presente no arquivo **authorized_keys** do servidor para garantir a permissão do cliente.

#### Windows

Observações sobre o Sistema Operacional Windows

- Windows 10 atualmente possui SSH nativo
- PUTTY é usado em versões antigas do Windows
- Git Bash e outros programas de terminal incluem o comando SSH e outras ferramentas Unix

#### Comandos

##### Básico

Os principais comandos SSH são respectivamente:

```bash
ssh {usuário}@{host}
```

Podemos por exemplo nos conectar ao host **bandit.labs.overthewire.org** com o usuário **bandit0** e a senha **bandit0**, com a opção **-p** podemos especificar a porta:

```bash
ssh bandit0@bandit.labs.overthewire.org -p 2220
# Será pedido a senha = bandit0
```

##### Gerando Chaves e Configurando Acesso

As chaves SSH são um meio seguro de nos conectarmos via SSH e podemos gerá-las com o seguinte comando:

```bash
ssh-keygen
```

Caso não especifiquemos um caminho, por padrão as chaves serão armazenadas em:

- `~/.ssh/id_rsa` (Chave privada)
- `~/.ssh/id_rsa.pub` (Chave pública)

Podemos confirmar o conteúdo dos arquivos com os comandos:

```bash
cat ~/.ssh/id_rsa
cat ~/.ssh/id_rsa.pub
``` 

Devemos agora copiar a **chave pública** para o servidor que desejamos usar, para isso podemos usar o seguinte comando:

```bash
cat ~/.ssh/id_rsa.pub | ssh akira@192.168.0.10 "mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >> ~/.ssh/authorized_keys"
```

Podemos também usar a ferramenta **scp** para copiarmos nossa chave para o servidor, veja que nesse caso específico enviamos para o servidor um arquivo com o nome `uploaded_key.pub` e agora devemos anexar o seu conteúdo ao arquivo `authorized_keys` para garantirmos a autorização do cliente:

```bash
scp ~/.ssh/id_rsa.pub akira@192.168.0.10:/home/akira/.ssh/uploaded_key.pub
cat ~/.ssh/uploaded_key.pub >> ~/.ssh/authorized_keys
```

Nossa chave pública agora estará armazenada no arquivo `~/.ssh/authorized_keys` do servidor, a partir de agora não precisaremos mais de senha para autenticação.

Para alterarmos as configurações do SSH podemos editar o arquivo `/etc/ssh/sshd_config`. Podemos por exemplo remover a permissão de login como **root** ao alterarmos `PermitRootLogin yes` para `PermitRootLogin no`.

Depois de editar o arquivo devemos recarregar o SSHD com o comando `systemctl reload sshd`.